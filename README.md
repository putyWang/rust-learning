## 从零开始学习Rust

### 1.配置rust开发环境

#### 1.1 windows安装

- 配置c++环境

  - 使用visual Studio 配置
    - **下载地址**：[Visual Studio 2022](https://visualstudio.microsoft.com/downloads/)；
    - **工作负载**（workload）
      - 使用 C++ 的桌面开发（Desktop Development with C++）；
      - Windows 10（或 11）SDK；
      - 英语语言包，以及其他你所需要的语言包；
  - 手动配置（ MinGW64 ）
    - **下载地址**：[MinGW-w64 - for 32 and 64 bit Windows - Browse /mingw-w64/mingw-w64-release at SourceForge.net](https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/) ；
    - **下载**： MinGW-W64 Online Installer；
    - 安装时系统设置
      - **版本（version）**：按需选取，默认选择最新版本；
      - **系统架构（architecture）**：64位系统配置x86-64，32位系统设置i686；
      - **操作系统接口协议（Threads）**：windows系统选择win32， 其他系统选择posix；
      - **异常处理模型（Exception）**：seh效率高不支持32位系统， SJLJ 兼容32位与64位但效率低于seh，dwarf只支持32位系统；
      - **备注**：
        - "the file has been downloaded incorrectly!"报错解决 时直接选择对应的离线安装包解压；
    - 环境变量配置
      - path中添加安装文件夹下的bin目录；
    - 安装完毕后使用g++ --version验证是否成功安装
- 安装配置rustUp

  - 下载地址： [Install Rust - Rust Programming Language (rust-lang.org)](https://www.rust-lang.org/tools/install) ；

  - 安装配置

    - These components can be acquired through a Visual Studio installer

      - 由于MinGW64  工具链构建的C++是用gnu 因此选择**选项3** (Don't install the prerequisites)；
- Current installation options:
  
  - 选择**选项2**自定义安装( Customize installation)  ；
      - 默认安装使用的 x86_64-pc-windows-msvc 与 MinGW64  使用的gnu不一致，需要修改为 x86_64-pc-windows-gnu；
      - 其他选项根据自己需求修改；
    - 安装完毕后使用rustc --version 验证是否安装成功；
- 配置开发软件（vscode）
  - 插件
    - rust-analyzer： 实时编译和分析 Rust 代码，提示错误，同时对类型进行标注 ；
    - Rust：Rust语言服务器；
    - rust syntax： 为代码提供语法高亮 ；
    - crates：依赖分析；
    - better toml： Rust 使用 toml 做项目的配置管理 ；
    - rust test lens： 快速运行 Rust 测试 ；
    - Tabnine：基于 AI 的自动补全，可以帮助你更快地撰写代码； 

### 2.cargo项目

#### 2.1 命令

- cargo new 项目名 创建项目；
- cargo run 项目名 运行项目；

#### 2.2 配置文件（Cargo.toml）

-  package： 设置项目的相关信息；

  - name：项目名（必填）；
    - 其它项目引用我们的 `package` 时，会使用该 `name`；
    - 编译出的可执行文件(bin target)的默认名称；
    - 限制
      - **使用 `cargo new` 或 `cargo init` 创建时**，`name` 还会被施加额外的限制；
      - 要发布到 `crates.io`时 `name` 需使用 `ASCII` 码，不能使用已经被使用的名称；
  - version：项目版本（必填）；
    - 符合 `"x.y.z"` 的形式，其中 `x` 被称为主版本(major), `y` 被称为小版本 `minor` ，而 `z` 被称为 补丁 `patch` ;
    - 使用标准的 `x.y.z` 形式的版本号，例如 `1.0.0` 而不是 `1.0`
    - 在版本到达 `1.0.0` 之前，怎么都行，但是如果有破坏性变更( breaking changes )，需要增加 `minor` 版本号；
    - 在 `1.0.0` 之后，如果发生破坏性变更，需要增加 `major` 版本号；
    - 在 `1.0.0` 之后，如果要添加新的 `pub` 结构体、特征、类型、函数、方法等对象时，增加 `minor` 版本号；
  - authors：作者；
  - edition： 指定项目所使用的rust版本；
  - rust-version： 用于说明你的项目支持的最低 Rust 版本(编译器能顺利完成编译) ；
  - description：项目简介；
  - documentation：项目文档地址；
  - readme：指向readme文件；
  - homepage：主页地址；
  - repository：设置项目源代码仓库地址；
  - license： 用于描述项目所遵循的开源协议；
  - license-file：用于指定包含开源协议的文件所在的路径(相对于 `Cargo.toml`) ；
  - keywords：项目关键字列表，用于cargo.io检索时使用；
  - categories：用于描述项目所属的类别；
  - workspace：用于配置当前项目所属的工作空间；
  - build：用于指定位于项目根目录中的构建脚本；
  - links：用于指定项目链接的本地库的名称；
  - exclude和include：这两个字段可以用于显式地指定想要包含在外或在内的文件列表；
  - publish：用于防止项目因为失误被发布到 crates.io 等注册服务上；
- metadata： 用户自定义的提供给外部工具的配置文件；
  
  - default-run：使用 cargo run 来运行项目时，该命令会使用默认的二进制可执行文件作为程序启动入口；
  
- badges： 用于指定项目当前的状态，展示在 `crates.io` 的项目主页；

  -  maintenance 是项目的当前维护状态，可能会被其它注册服务所使用；
     -  status 字段时必须的
        -  actively-developed: 正在增加新功能及修复bug；
        -  passively-maintained: 项目停止添加新功能，项目维护者可能会回答你提出的issue；
        -  as-is: 项目已经结束且功能已达预期，维护者不准备继续开发和提供支持；
        -  experimental: 作者希望同大家分享，但是还不准备满足任何人的特殊要求；
        -  looking-for-maintainer: 维护者希望将项目转移给新的维护者；
        -  deprecated: 不再推荐使用该项目，同时说明原因以及推荐的替代项目；
        -  none:  不显示任何 badge；

- dependencies：引用三方依赖包；

  -  依赖包版本设置
     -  ^ 可以指定一个版本号范围，然后会使用该范围内的最大版本号来引用对应的包；
     -  ~ 指定了最小化版本；
     -  `*` 通配符允许将 `*` 所在的位置替换成任何数字；
     -  使用比较符的方式来指定一个版本号范围或一个精确的版本号， 同时还能使用比较符进行组合，并通过逗号分隔；

  - 从其它注册服务引入依赖包
    - 第一种：
      -  在 crates.io 之外添加新的注册服务；
      -  在引用依赖包时要指定注册服务；
    - 第二种
      -  直接使用新注册服务来替代默认的 crates.io；
  - 引入 git 仓库作为依赖包；
  - 通过路径引入本地依赖包；
  - 根据特定的平台来引入依赖；

  ```toml
  [package]
  name = "rust-test"
  version = "0.1.0"
  edition = "2021"
  
  [registries]
  ustc = { index = "https://mirrors.ustc.edu.cn/crates.io-index/" }
  
  [badges]
  maintenance = { status = "..." }
  
  # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
  
  [dependencies]
  # ^1:[>=1.0.0, <2.0.0]
  # *     := >=0.0.0
  # 1.*   := >=1.0.0, <2.0.0
  # 1.2.* := >=1.2.0, <1.3.0
  # >= 1.2, < 1.5
  # time = {  registry = "ustc" }
  time = "0.1.12"
  # 引入 git 仓库作为依赖包
  regex = { git = "https://github.com/rust-lang/regex" }
  
  # 通过路径引入本地依赖包
  # 以下路径也可以
  # hello_utils = { path = "./hello_utils" }
  # hello_utils = { path = "../hello_world/hello_utils" }
  hello_utils = { path = "hello_utils" }
  
  # 引入windows操作平台依赖
  [target.'cfg(windows)'.dependencies]
  winhttp = "0.4.0"
  # 引入unix操作平台依赖
  [target.'cfg(unix)'.dependencies]
  openssl = "1.0.1"
  # 引入x86架构平台依赖
  [target.'cfg(target_arch = "x86")'.dependencies]
  native = { path = "native/i686" }
  # 引入x86_64架构平台依赖
  [target.'cfg(target_arch = "x86_64")'.dependencies]
  native = { path = "native/x86_64" }
  
  # 直接使用新注册服务来替代默认的 crates.io
  [source.crates-io]
  replace-with = 'ustc'
  
  [source.ustc]
  registry = "git://mirrors.ustc.edu.cn/crates.io-index"
  ```

### 3.基础知识

#### [3.1 变量](./foundation/variable/src/main.rs)

- 使用 let 关键字进行申明（但不可被二次赋值）；
- 使用 mut 关键字修饰的变量可被二次赋值；
- 常量是使用 const 进行申明的一个不允许改变值的变量（类似与未使用 mut 修饰的变量）；
  - 总是不变的，不允许使用mut进行修饰；
  - 常量必须注明值的类型；
  - 任何作用域中都可以被声明，包括全局作用域；
  - 常量只能被设置为常量表达式，不能为运行时计算出的值；
- 变量的隐藏
  - 通过定义与已定义变量的同名变量可实现对之前定义变量的隐藏；
  - 单一变量可以被重复多次隐藏；
  - 隐藏之后的所有操作都视作对之后的变量所作；
  - 在变量的作用域结束后，才会结束对之前变量的隐藏；
  - 隐藏实际上相当于创建新变量，申明变量类型可以与之前不一致；

#### [3.2 数据类型](./foundation/data_type/src/main.rs)

- **标量**（*scalar*）代表一个单独的值；

  - **整型**没有小数部分的数字；

    - 允许使用 `_` 做为分隔符以方便读数；

    - 允许使用字面量表中所有方式标识数据；

    - 类型表

      | **长度** | **有符号** | **无符号** |
      | -------- | ---------- | ---------- |
      | 8-bit    | i8         | u8         |
      | 16-bit   | i16        | u16        |
      | 32-bit   | i32        | u32        |
      | 64-bit   | i64        | u64        |
      | 128-bit  | i128       | u128       |
      | arch     | isize      | usize      |

      -  `isize` 和 `usize` 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的，32 位架构上它们是 32 位的 ；

    - 字面量表

      | 数字字面值                    | 示例        |
      | ----------------------------- | ----------- |
      | Decimal (十进制)              | 98_222      |
      | Hex (十六进制)                | 0xff        |
      | Octal (八进制)                | 0o77        |
      | Binary (二进制)               | 0b1111_0000 |
      | Byte (单字节字符)(仅限于`u8`) | b'A'        |

  - **浮点型**（*floating-point numbers*）带小数点的数字；

    - 采用 IEEE-754 标准进行表示；
    - 两种原生：f64（64位双精度浮点数）与f32（32位单精度浮点数）；
    - 默认声明为64位双精度浮点数；

  - **布尔型**（boolean）

    - 两个可能的值：`true` 和 `false`；

  - **字符类型**（char）

    - 使用单引号（'）声明的字面量；
    - 大小为四个字节，代表一个 Unicode 标量值（ 从`U+0000`到`U+D7FF`和`U+E000`到`U+10FFFF`在内的值 ）；

- **复合类型**多个值组合成一个类型；

  - **元组类型**(元素1类型, 元素2类型, 元素3类型...)
    - 将多个其他类型的值组合进一个复合类型的主要方式；
    - 元组长度一旦声明，就不会增大或缩小；
    - 使用圆括号中的逗号分隔的值列表来创建；
    - 元组中数据的访问
      - **解构**：声明新的变量组将元组的所有值匹配对应赋值；
      - **直接访问**：直接使用元组名.index对指定位置的值进行访问（index 从0开始）；
    - **单元元组**：不带任何值的元组；
  - **数组类型**（[数据类型;数组长度]）
    - 数组中的每个元素的类型必须相同；
    - 数组长度是固定的；
    - 使用方括号中的逗号分隔的相同类型值列表来创建；
    - 通过使用方括号包含数组元素类型+分号+数组元素的数量；
    - 也可以使用[元素值;元素个数]的方式创建元素值相同的数组；
    - 数组中元素的访问
      - 使用索引对数据进行访问（数组名[index]， index 索引是从0开始）；
      - 访问无效的索引时会直接抛出异常；

#### [3.2 函数](./foundation/function/src/main.rs)

- 声明
  - 使用 fn 关键字对函数进行声明；
  - 使用  snake case 风格进行命名，字母都是小写并使用下划线分隔单词；
  - 定义格式：fn 函数名(参数列表)；
  - 声明时必须指定指定参数的数据类型；
  - 参数列表中不同参数使用逗号进行分隔；
  - 函数需要返回值时，需要在参数列表括号后加上 -> 返回值类型 定义返回值类型；
- 函数体
  -  函数体由一系列的语句和一个可选的结尾表达式构成 
    - **语句**（*Statements*）是执行一些操作但不返回值的指令；
    - **表达式**（*Expressions*）计算并产生一个值；
    - 表达式结尾不能以分号（;）结尾表示该列产生为返回值

#### [3.3 控制流](./foundation/control_stream/src/main.rs)

- **if 表达式**
  - 以 `if` 关键字开头，然后跟一个条件；
  - 条件计算结果需为bool类型值，否则会编译失败；
  - 在条件之后跟随条件为真时执行的语句；
  - 存在多个判断条件分支时，在 if 语句之后 使用else if 进行分支判断；
  - 最后使用 else 关键字处理余量数据；
  - 由于if 语句为表达式，因此可以在let 语句中直接使用；
  - 在 let 语句中使用时，所有分支表达式的结果类型必须一致；
- 循环语句
  - **loop 语句**
    - 重复执行指定语句，直到手动停止（ctrl + c）；
    - 使用 continue 语句可以跳过本次循环中的剩余语句直接进入下一次循环；
    - 使用break语句不仅可以跳出循环，break 语句执行结果还将作为整个loop语句的返回值；
    - 循环嵌套的情况之下，可以通过对循环打标签的方式指定具体跳出哪个循环；
    - 不指定跳出循环标签名，跳出所处最内层循环；
  - **while条件循环**
    - while 条件 循环体 格式进行声明；
    - 在条件满足时，执行循环体中的内容直到条件不满足；
  - **for 循环**
    - for 循环 通常用来遍历集合中的所有元素；
    - for 元素名 in 集合名 {循环体}；

### 4.所有权

#### [4.1 基础定义](./scope/base/src/main.rs)

- 基础规则
  - Rust 中的每一个值都有一个 **所有者**（*owner*）；
  - 值在任一时刻有且只有一个所有者；
  - 当所有者（变量）离开作用域，这个值将被丢弃；
- 变量作用域
  - 作用域是使用{}包含的一段代码段；
  -  作用域是一个项（item）的有效作用范围；
  - 当 `s` **进入作用域** 时，它就是有效的；
  - 这一直持续到它 **离开作用域** 为止；
- 内存分配
  - 声明变量时，程序申请变量所需内存；
  - 内存在拥有它的变量离开作用域后就被自动释放；
  - 当变量离开作用域，Rust 为我们调用 drop 函数，清除特定内存；
  - 变量赋值给另一个变量时移动出现移动，当持有堆中数据值的变量离开作用域时通过 `drop` 被清理掉，除非数据被移动为另一个变量所有；
  - **移动**
    - **二次释放**：由于存储在堆上的数据，变量名存储的是指向内存的指针，如果赋值给一个新变量，在离开作用域时释放内存的时候会出现多次释放同一位置内存的问题；
    - **移动**：使用 = 将存储在堆上的对象赋值给新变量时会使得之前的变量失效；
    - 移动之后再使用之前变量会导致编译出错（borrow of moved value: `s`）；
    - 移动之后由于旧变量已无效，已无需释放内存，因此只会释放一次内存，避免了二次释放问题；
  - **克隆**
    - 使用 clone 是将堆中的数据复制一份，新变量存储着指向复制后数据的指针；
  - **拷贝**
    - 使用 = 将存储在栈上的数据赋值给新变量就直接将栈上数据复制一份给新变量；
    - 实现copy的类型就是使用拷贝；
    - 任何一组简单标量值的组合都可以实现 `Copy`；
    - 任何不需要分配内存或某种形式资源的类型都可以实现 `Copy`；
    - 实现了copy的类型
      - 所有整数类型，比如 `u32`；
      - 布尔类型，`bool`，它的值是 `true` 和 `false`；
      - 所有浮点数类型，比如 `f64`；
      - 字符类型，`char`；
      - 当且仅当其包含的类型都实现 `Copy` 的元组；
- 所有权与函数
  - 函数传参的规则也与=赋值规则一致；
  - 对未实现copy的类型采取的就是移动的方式；
  - 当出现移动的情况时，程序编译出错（borrow of moved value: `s`）提示你这个地方产生了移动，需要你使用clone的方式进行传参；
  - 实现copy的类型采取的就是拷贝的方式；
  - 函数返回值采取的是移动的方式返回给调用它的函数；

#### [4.2 引用](./scope/references_and_borrowing/src/main.rs)

- **基本知识**

  - 像一个指针，存储的是一个地址，能够访问储存于该地址的属于其他变量的数据；

  - 与指针不同在于引用指向的数据具有特定数据类型，不可更改；

  - 函数定义时采用 (&数据类型) 的方式表明需要传入引用，使用时则采用 (&数据名)方式表示传递指定数据的引用；

  - 引用实际上表示 可以使用该数据，但却不获取该数据的所有权；

  - 由于引用没有数据的所有权，因此在离开对应的作用域时，也不会丢弃和清理对应的数据内存；

  - 和变量默认不可变一样，引用也是默认不能被更改的；

    

- **可变引用**

  - 同时在传参除数据名前以及接收参数定义的类型名前添加(mut)关键字将使得我们能够在使用时修改引用对应的值；
  - 只有源数据值也是可变时，才能作为可变引用进行传参；
  - 在某个变量**任何引用**未失效的情况下，由于要避免**数据竞争**问题，再次创建同一变量的可变引用会导致之前所有引用全部失效（就算离开了第二个可变引用的作用域，同样也是失效的）；
  - 创建**新的不可变引用**同样会导致之前**可变引用**的失效；
  - **数据竞争**产生原因
    - 两个或更多指针同时访问同一数据；
    - 至少有一个指针被用来写入数据；
    - 没有同步数据访问的机制；

- **悬垂引用**

  - **悬垂指针**：指向的内存可能已经被分配给其它持有者；
  - 通过确保数据不会在其引用之前离开作用域来避免**悬垂引用**问题的发生；

#### [4.3 Slice 类型](./scope/slice/src/main.rs)

-  *slice* 允许引用**集合中一段连续的元素序列**，而不用引用整个集合；
- **字符串slice**
  - **字符串 slice**（*string slice*）是 `String` 中一部分值的引用，声明写做 &str；
  - &字符串变量名[startIndex..endIndex] 表示从该变量从startIndex到endIndex的局部引用；
  - 字符串 slice 引用包含startIndex，不包含endIndex；
  - 当 startIndex 为0时，可以省略，直接使用[..endIndex]表示从0到endIndex的局部引用；
  - 当endIndex 表示到 String 的结尾，endIndex 也可被省略；
  - 源数据出现任意改变时候会导致该数据绑定的 字符串slice 失效；
  - 字符串字面量数据类型实际上就是 字符串slice；
  - 对字符串的引用 相当于 对字符串的全量 slice；

### 5.结构体

#### [5.1 定义与实例化](./struct/define_and_instant/src/main.rs)

- 使用 **struct** 关键字定义一个结构体；
- 结构定义语法：struct 结构名 {结构体}；
- 结构体名采用 **首字母大写的驼峰命名** 方式进行命名；
- 结构体中 **字段** 采取 **字段名:字段类型** 的方式进行定义；
- 不同字段之间使用 逗号（,）进行分隔；
- 结构体实例化采取的是 **结构名 {key:value,key:value,...}** 方式进行；
- 实例化语句中的 key:value 表示 将名为 **key 字段赋值为 value**；
- 在结构体实例化之后，可以使用 **实例化对象名.字段名** 的方式访问对应字段数据；
- 在实例化对象可变时，能够使用 **实例化对象名.字段名** 的方式给对应字段赋值；
- 只能设置实例化对象是否可变，而不能单独设置某个字段是否可变；
- 若参数名与字段名一致，则可以省略 :参数名 直接使用字段名对指定字段赋值；
- 结构体更新语法
  - 若新的示例对象与旧对象部分字段值相同，可以使用 **结构名{差异字段赋值, ..旧实例名}** 的方式进行赋值；
  - ..旧实例名 只能放在**赋值语句的结尾**）；
  - .**.旧实例名** 相当于 **=** 符号赋值，也会出现移动等相关问题；
- 使用 **Struct 结构体名{数据类型, 数据类型,...}** 定义无字段名的**元组结构体**；
- 元组结构体对对应数据访问与元组一致；
- 使用 **Struct 结构体名** 定义一个没有任何字段的**类单元结构体**； 

#### [5.2 方法与关联函数](./struct/method/src/main.rs)

- 与函数一样，方法也是使用 **fn关键字** 进行定义；
- 第一个参数总是 **self** ，代表的是本函数所属结构体实例；
- 在 impl 块中，使用大写开头的 **Self** 代表相关的结构体数据类型；
- 实际定义时，需要使用 & 前缀 表示借用，与其他引用一致，当需要改变对象时，也需要加上mut；
- 方法的定义
  - 使用 **impl 结构体名{impl块}** 定义方法所属的结构体上下文；
  - 在方法结构体可以定义多个方法；
  - 使用 fn 方法名( &self , 其余参数){方法体} 定义方法；
  - 其余参数可以为0个；
  - 调用方法时，需传除 &self 以外的所有参数；
- **关联函数**
  - 所有在 impl 块中定义的函数；
  - 关联函数参数列表不以 self 开头，因此并非为方法；
  - 构造函数常使用 new 命名的， 返回一个结构体新实例的函数；
  - 使用 **结构体名::关联函数名** 调用指定结构体的关联函数；
- 每个结构体都允许拥有多个impl块；

### 6.枚举

#### [6.1 定义](./enums/define/src/main.rs)

- 枚举是用来列举 **同一数据所有可能值** 的数据结构；
- 使用 **enum 枚举名{值1, 值2,...}** 对枚举进行定义；
- 每个枚举值被称为枚举的**成员**；
- 与访问 关联函数 一致，使用 **枚举名::枚举值** 方式获取某个枚举值；
- 枚举值的类型全部为 该枚举；
- 每个成员可以绑定 **不同类型和数量** 的数据；
- 使用 **成员名(数据类型1,...)** 声明成员与数据绑定语法；
- **任意类型的数据**放入枚举成员中：例如字符串、数字类型或者结构体；
- 与 结构体 一致， 可以使用 impl 来为枚举定义方法群；

#### **[6.2 match 控制流](./enums/match_control/src/main.rs)**

- match 表示分支选择，与switch... case 使用方法一致；
- 使用 **match 枚举参数 {枚举值1 => {符合1时执行代码}, 枚举值2 => {符合2时执行代码}...}** 的语法使用；
- 代码只有一行时可以省略{}；
- 使用{}包裹执行代码时，可以省略每个分支之后的 , ；
- 如果执行代码为一个表达式时，**分支的返回值**将作为整个match控制流的返回值；

- 在匹配分支表达式枚举值可以使用 **枚举值(绑定数据名)** 作为条件以获取该枚举值绑定的数据；
- 匹配需要被穷尽的，若有**一个枚举值没被列举出来，将会报错**；
- 除了匹配枚举，还能匹配基础数据；
- 不想穷举所有选项时，可以使用 **other或者通配符(_)** 表示其余情况；
- 当只**需要一个分支时** 可以使用 **if let** 的方式替代match；